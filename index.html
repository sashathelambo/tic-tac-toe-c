<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tic-Tac-Toe Game</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <style>
        .board {
            display: grid;
            grid-template-columns: repeat(3, 100px);
            grid-gap: 10px;
            margin: 20px auto;
        }
        
        .cell {
            width: 100px;
            height: 100px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2em;
            background-color: #61dafb;
            border: 2px solid #20232a;
            border-radius: 10px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.3s;
        }
        
        .cell:hover {
            background-color: #21a1f1;
            transform: scale(1.1);
        }
        
        .cell.x {
            color: #ff6b6b;
        }
        
        .cell.o {
            color: #4db6ac;
        }
        
        .active-mode {
            border: 2px solid #fff;
        }
        
        .highlight {
            background-color: #ffeb3b;
        }
        
        @media (max-width: 600px) {
            .board {
                grid-template-columns: repeat(3, 80px);
                grid-gap: 5px;
            }
            .cell {
                width: 80px;
                height: 80px;
                font-size: 1.5em;
            }
        }
    </style>
</head>

<body class="bg-gray-900 text-white flex flex-col items-center justify-center min-h-screen p-4">
    <h1 class="text-4xl font-bold text-blue-400 mb-4">Welcome to Tic-Tac-Toe!</h1>
    <div class="instructions bg-gray-800 p-6 rounded-lg shadow-lg max-w-lg text-center">
        <h2 class="text-2xl font-semibold text-blue-400 mb-4">Instructions</h2>
        <p class="mb-4">This is a web-based Tic-Tac-Toe game. Click on a cell to make a move. The first player to align three of their marks in a row, column, or diagonal wins!</p>
    </div>
    <div class="board" role="grid" aria-label="Tic-Tac-Toe Board"></div>
    <div id="message" class="text-xl mt-4" aria-live="polite"></div>
    <button id="resetBtn" class="mt-4 bg-blue-500 text-white px-4 py-2 rounded">Reset Game</button>
    <div class="mt-4">
        <button id="playerVsPlayerBtn" class="bg-green-500 text-white px-4 py-2 rounded">Player vs Player</button>
        <button id="playerVsComputerBtn" class="bg-red-500 text-white px-4 py-2 rounded">Player vs Computer</button>
    </div>
    <div class="mt-4">
        <button id="easyBtn" class="bg-yellow-500 text-white px-4 py-2 rounded">Easy</button>
        <button id="mediumBtn" class="bg-orange-500 text-white px-4 py-2 rounded">Medium</button>
        <button id="hardBtn" class="bg-purple-500 text-white px-4 py-2 rounded">Hard</button>
    </div>
    <div class="mt-4">
        <button id="darkModeBtn" class="bg-gray-700 text-white px-4 py-2 rounded">Dark Mode</button>
        <button id="lightModeBtn" class="bg-gray-300 text-black px-4 py-2 rounded">Light Mode</button>
    </div>
    <div class="mt-4">
        <h2 class="text-2xl font-semibold text-blue-400 mb-4">Game History</h2>
        <ul id="gameHistory" class="bg-gray-800 p-6 rounded-lg shadow-lg max-w-lg text-center"></ul>
    </div>
    <footer class="mt-auto text-gray-500">
        <p>&copy; 2024 Tic-Tac-Toe Game. All rights reserved.</p>
    </footer>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.min.js"></script>

    <script>
        const boardElement = document.querySelector('.board');
        const messageElement = document.getElementById('message');
        const resetBtn = document.getElementById('resetBtn');
        const playerVsPlayerBtn = document.getElementById('playerVsPlayerBtn');
        const playerVsComputerBtn = document.getElementById('playerVsComputerBtn');
        const easyBtn = document.getElementById('easyBtn');
        const mediumBtn = document.getElementById('mediumBtn');
        const hardBtn = document.getElementById('hardBtn');
        const darkModeBtn = document.getElementById('darkModeBtn');
        const lightModeBtn = document.getElementById('lightModeBtn');
        const gameHistoryElement = document.getElementById('gameHistory');

        let board = Array.from({
            length: 9
        }, (_, i) => (i + 1).toString());
        let currentPlayer = 'X';
        let isPlayerVsComputer = false;
        let difficulty = 'medium';
        let socket = io();
        let gameHistory = [];

        function displayBoard(board) {
            boardElement.innerHTML = '';
            board.forEach((cell, index) => {
                const cellElement = document.createElement('div');
                cellElement.classList.add('cell');
                cellElement.textContent = cell;
                cellElement.addEventListener('click', () => handleClick(index));
                boardElement.appendChild(cellElement);

                if (cell === 'X') {
                    cellElement.classList.add('x');
                } else if (cell === 'O') {
                    cellElement.classList.add('o');
                }
            });
        }

        function checkWin(board) {
            const winPatterns = [
                [0, 1, 2],
                [3, 4, 5],
                [6, 7, 8],
                [0, 3, 6],
                [1, 4, 7],
                [2, 5, 8],
                [0, 4, 8],
                [2, 4, 6]
            ];

            for (const pattern of winPatterns) {
                const [a, b, c] = pattern;
                if (board[a] && board[a] === board[b] && board[a] === board[c]) {
                    return pattern; // Return winning pattern
                }
            }

            return null; // No winner yet
        }

        function isDraw(board) {
            return board.every(cell => cell === 'X' || cell === 'O');
        }

        function resetBoard() {
            board = Array.from({
                length: 9
            }, (_, i) => (i + 1).toString());
            currentPlayer = 'X';
            messageElement.textContent = '';
            displayBoard(board);
            gameHistory = [];
            gameHistoryElement.innerHTML = '';
            if (isPlayerVsComputer && currentPlayer === 'O') {
                computerMove();
            }
        }

        function handleClick(index) {
            if (board[index] !== 'X' && board[index] !== 'O' && !checkWin(board)) {
                board[index] = currentPlayer;
                displayBoard(board);
                socket.emit('playerMove', {
                    board,
                    currentPlayer
                });

                const winningPattern = checkWin(board);
                if (winningPattern) {
                    highlightWinningCells(winningPattern);
                    messageElement.textContent = `${currentPlayer} wins!`;
                    socket.emit("gameOver", `${currentPlayer} wins!`)
                    playSound('gameOver');
                    addToGameHistory(`${currentPlayer} wins!`);
                    return;
                }

                if (isDraw(board)) {
                    messageElement.textContent = 'It\'s a draw!';
                    socket.emit("gameOver", 'It\'s a draw!');
                    playSound('gameOver');
                    addToGameHistory('It\'s a draw!');
                    return;
                }

                currentPlayer = currentPlayer === 'X' ? 'O' : 'X';

                if (isPlayerVsComputer && currentPlayer === 'O') {
                    computerMove();
                }
            }
        }

        function computerMove() {
            setTimeout(() => {
                let bestMove;

                if (difficulty === "easy") {
                    bestMove = getRandomAvailableMove();
                } else if (difficulty === "medium") {
                    bestMove = getMediumDifficultyMove();
                } else {
                    bestMove = getMinimaxMove(board, currentPlayer);
                }

                board[bestMove] = currentPlayer;
                displayBoard(board);
                socket.emit('playerMove', {
                    board,
                    currentPlayer
                });

                const winningPattern = checkWin(board);
                if (winningPattern) {
                    highlightWinningCells(winningPattern);
                    messageElement.textContent = `${currentPlayer} wins!`;
                    socket.emit("gameOver", `${currentPlayer} wins!`)
                    playSound('gameOver');
                    addToGameHistory(`${currentPlayer} wins!`);
                    return;
                }

                if (isDraw(board)) {
                    messageElement.textContent = 'It\'s a draw!';
                    socket.emit("gameOver", 'It\'s a draw!');
                    playSound('gameOver');
                    addToGameHistory('It\'s a draw!');
                    return;
                }

                currentPlayer = currentPlayer === 'X' ? 'O' : 'X';
            }, 500);
        }

        function getRandomAvailableMove() {
            const availableMoves = board.filter(cell => cell !== 'X' && cell !== 'O');
            return availableMoves[Math.floor(Math.random() * availableMoves.length)];
        }

        function getMediumDifficultyMove() {
            const availableMoves = board.map((cell, index) => cell !== 'X' && cell !== 'O' ? index : null).filter(index => index !== null);
            const winningMove = availableMoves.find(index => {
                const tempBoard = [...board];
                tempBoard[index] = currentPlayer;
                return checkWin(tempBoard);
            });
            if (winningMove !== undefined) {
                return winningMove;
            }
            const blockingMove = availableMoves.find(index => {
                const tempBoard = [...board];
                tempBoard[index] = currentPlayer === 'X' ? 'O' : 'X';
                return checkWin(tempBoard);
            });

            if (blockingMove !== undefined) {
                return blockingMove;
            }
            return getRandomAvailableMove();
        }

        function getMinimaxMove(board, player) {
            const availableMoves = board.map((cell, index) => cell !== 'X' && cell !== 'O' ? index : null).filter(index => index !== null);

            let bestScore = -Infinity;
            let bestMove;

            for (let i = 0; i < availableMoves.length; i++) {
                const move = availableMoves[i];
                board[move] = player;
                const score = minimax(board, 0, false);
                board[move] = (move + 1).toString();

                if (score > bestScore) {
                    bestScore = score;
                    bestMove = move;
                }
            }

            return bestMove;
        }

        function minimax(board, depth, isMaximizing) {
            const winner = checkWin(board);

            if (winner) {
                return winner[0] === 'O' ? 10 - depth : depth - 10;
            }

            if (isDraw(board)) {
                return 0;
            }

            const availableMoves = board.map((cell, index) => cell !== 'X' && cell !== 'O' ? index : null).filter(index => index !== null);

            if (isMaximizing) {
                let bestScore = -Infinity;
                for (let i = 0; i < availableMoves.length; i++) {
                    const move = availableMoves[i];
                    board[move] = 'O';
                    const score = minimax(board, depth + 1, false);
                    board[move] = (move + 1).toString();
                    bestScore = Math.max(score, bestScore);
                }
                return bestScore;
            } else {
                let bestScore = Infinity;
                for (let i = 0; i < availableMoves.length; i++) {
                    const move = availableMoves[i];
                    board[move] = 'X';
                    const score = minimax(board, depth + 1, true);
                    board[move] = (move + 1).toString();
                    bestScore = Math.min(score, bestScore);
                }
                return bestScore;
            }
        }

        function highlightWinningCells(pattern) {
            pattern.forEach(index => {
                boardElement.children[index].classList.add('highlight');
            });
        }

        function playSound(sound) {
            let audio;
            switch (sound) {
                case 'move':
                    audio = new Audio('https://opengameart.org/sites/default/files/select_0.wav'); // Replace with your move sound
                    break;
                case 'gameOver':
                    audio = new Audio('https://opengameart.org/sites/default/files/Buzzer3.wav'); // Replace with your game over sound
                    break;
            }
            audio.play();
        }

        function addToGameHistory(result) {
            gameHistory.push(result);
            updateGameHistoryDisplay();
        }

        function updateGameHistoryDisplay() {
            gameHistoryElement.innerHTML = '';
            gameHistory.forEach(result => {
                const listItem = document.createElement('li');
                listItem.textContent = result;
                gameHistoryElement.appendChild(listItem);
            });
        }

        resetBtn.addEventListener('click', resetBoard);

        playerVsPlayerBtn.addEventListener('click', () => {
            isPlayerVsComputer = false;
            resetBoard();
            playerVsPlayerBtn.classList.add('active-mode');
            playerVsComputerBtn.classList.remove('active-mode');
        });

        playerVsComputerBtn.addEventListener('click', () => {
            isPlayerVsComputer = true;
            resetBoard();
            playerVsComputerBtn.classList.add('active-mode');
            playerVsPlayerBtn.classList.remove('active-mode');
            if (currentPlayer === 'O') {
                computerMove();
            }
        });

        easyBtn.addEventListener('click', () => {
            difficulty = 'easy';
            easyBtn.classList.add('active-mode');
            mediumBtn.classList.remove('active-mode');
            hardBtn.classList.remove('active-mode');
            if (isPlayerVsComputer && currentPlayer === 'O') {
                computerMove();
            }
        });

        mediumBtn.addEventListener('click', () => {
            difficulty = 'medium';
            mediumBtn.classList.add('active-mode');
            easyBtn.classList.remove('active-mode');
            hardBtn.classList.remove('active-mode');
            if (isPlayerVsComputer && currentPlayer === 'O') {
                computerMove();
            }
        });

        hardBtn.addEventListener('click', () => {
            difficulty = 'hard';
            hardBtn.classList.add('active-mode');
            easyBtn.classList.remove('active-mode');
            mediumBtn.classList.remove('active-mode');
            if (isPlayerVsComputer && currentPlayer === 'O') {
                computerMove();
            }
        });

        darkModeBtn.addEventListener('click', () => {
            document.body.classList.add('bg-gray-900', 'text-white');
            document.body.classList.remove('bg-white', 'text-black');
        });

        lightModeBtn.addEventListener('click', () => {
            document.body.classList.add('bg-white', 'text-black');
            document.body.classList.remove('bg-gray-900', 'text-white');
        });

        // Socket event listeners
        socket.on('playerMove', ({
            board: newBoard,
            currentPlayer: newCurrentPlayer
        }) => {
            board = newBoard;
            currentPlayer = newCurrentPlayer;
            displayBoard(board);
        });

        socket.on('resetBoard', () => {
            resetBoard();
        });

        socket.on('gameOver', (message) => {
            messageElement.textContent = message;
            playSound('gameOver');
        });


        displayBoard(board);

        // Add test logic if needed
        const testLogic = {
            testCheckWin: () => {
                // Test cases for checkWin function
                console.assert(checkWin(['X', 'X', 'X', 4, 5, 6, 7, 8, 9]) !== null, 'Horizontal win not detected');
                console.assert(checkWin([1, 2, 3, 'O', 'O', 'O', 7, 8, 9]) !== null, 'Horizontal win not detected');
                console.assert(checkWin([1, 2, 3, 4, 5, 6, 'X', 'X', 'X']) !== null, 'Horizontal win not detected');
            },
            testIsDraw: () => {
                // Test cases for isDraw function
                console.assert(isDraw(['X', 'O', 'X', 'O', 'X', 'X', 'O', 'X', 'O']) === true, 'Draw not detected');
                console.assert(isDraw(['X', 'O', 'X', 'O', 'X', 'X', 'O', 'X', 9]) === false, 'Incorrect draw detection');
            }
        };

        // Run tests
        testLogic.testCheckWin();
        testLogic.testIsDraw();

        // Set difficulty to easy by default
        easyBtn.classList.add('active-mode');
    </script>
</body>

</html>